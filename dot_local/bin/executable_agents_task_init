#!/usr/bin/env bash
# agents_task_init - Initialize THIS_BRANCH.md and check_this_branch.sh for task/change work
# Usage: Run from project root when starting new branch work. Safe to run multiple times.

set -e

# Colors for output (if terminal supports it)
if [ -t 1 ]; then
    BOLD='\033[1m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    RED='\033[0;31m'
    RESET='\033[0m'
else
    BOLD='' GREEN='' YELLOW='' BLUE='' RED='' RESET=''
fi

printf "${BOLD}üîß Initializing branch metadata files${RESET}\n\n"

# Check we're in a reasonable directory
if [ ! -d .git ] && [ ! -d .jj ]; then
    printf "${RED}‚ùå Error: Not in a git or jj repository root${RESET}\n"
    printf "   Run this script from your project root directory\n"
    exit 1
fi

# Get current date
TODAY=$(date '+%Y-%m-%d')

# Detect if files already exist
FILES_EXIST=false
if [ -f THIS_BRANCH.md ] && [ -f check_this_branch.sh ]; then
    FILES_EXIST=true
fi

# Get jj context if available
CURRENT_CHANGE=""
BOOKMARK_NAME=""
if command -v jj >/dev/null 2>&1; then
    CURRENT_CHANGE=$(jj log -r @ --no-graph -T 'change_id.short(7)' 2>/dev/null || echo "")
    CURRENT_DESC=$(jj log -r @ --no-graph -T 'description.first_line()' 2>/dev/null || echo "")
    BOOKMARK_NAME=$(jj log -r @ --no-graph -T 'bookmarks' 2>/dev/null | head -1 || echo "")
    if [ "$BOOKMARK_NAME" = "(no bookmarks)" ] || [ -z "$BOOKMARK_NAME" ]; then
        BOOKMARK_NAME=""
    fi
fi

# === 1. Create THIS_BRANCH.md ===
if [ "$FILES_EXIST" = false ]; then
    printf "${BLUE}üìù Creating THIS_BRANCH.md...${RESET}\n"
fi

if [ -f THIS_BRANCH.md ]; then
    if [ "$FILES_EXIST" = false ]; then
        printf "   Already exists - skipping\n"
    fi
else
    # Determine branch name for template
    BRANCH_NAME="${BOOKMARK_NAME:-<bookmark-name>}"
    if [ -z "$BOOKMARK_NAME" ]; then
        BRANCH_NAME="<bookmark-name or change description>"
    fi

    cat > THIS_BRANCH.md <<EOF
# Branch: ${BRANCH_NAME}

**Created:** $TODAY
**Last Updated:** $TODAY
**Change ID:** ${CURRENT_CHANGE:-<jj change-id>}

## Scope

What changes are in scope for this branch/lineage?

## Out of Scope

What explicitly will NOT be done here?

## How to Use check_this_branch.sh

**When to run:**
- Before each \`jj new\` (creating new change)
- Before \`jj describe\` (updating change description)
- Before \`jj git push\` (pushing bookmark)
- After adding new files to the branch

**What it checks:**
- FIXME comments (blocking - MUST fix before publishing)
- TODO comments (informational only)
- Branch metadata files not included in changes

**If it fails:**
1. Read error messages carefully
2. Fix FIXME comments or convert to TODO
3. Re-run until it passes
4. DO NOT push if check fails

**Updating the file list:**
- Current scope: Files matching \`<pattern>\` (e.g., \`src/feature/\`, \`docs/\`)
- If you start editing files outside this pattern, add them to CHECK_FILES in check_this_branch.sh
- Keep CHECK_FILES as a static list - do NOT use dynamic VCS queries

## TODO

- [ ] Define scope and out-of-scope sections above
- [ ] Update CHECK_FILES in check_this_branch.sh with relevant files
- [ ] Run check_this_branch.sh to verify it works
- [ ] Add project-specific checks to check_this_branch.sh as needed

## Consolidation Plan

**Checks to migrate to permanent project infrastructure:**
- (Add checks here as they stabilize during branch work)
- Example: SVG validation ‚Üí Create \`scripts/validate-svgs.sh\`

**Migration should happen:**
- Throughout branch work when checks stabilize
- Before publishing, ensure all useful checks have permanent homes

## Notes

- (Add notes about decisions, discoveries, etc.)

## Cleanup Checklist (before publish)

- [ ] All in-scope TODOs completed or moved elsewhere
- [ ] Useful checks migrated to permanent project infrastructure
- [ ] Remove/exclude THIS_BRANCH.md from final change(s)
- [ ] Remove/exclude check_this_branch.sh from final change(s)
EOF
    printf "   ${GREEN}‚úÖ Created THIS_BRANCH.md${RESET}\n"
fi

# === 2. Create check_this_branch.sh ===
if [ "$FILES_EXIST" = false ]; then
    printf "${BLUE}üîç Creating check_this_branch.sh...${RESET}\n"
fi

if [ -f check_this_branch.sh ]; then
    if [ "$FILES_EXIST" = false ]; then
        printf "   Already exists - skipping\n"
    fi
else
    # Determine branch name for template
    BRANCH_NAME="${BOOKMARK_NAME:-<bookmark-name>}"

    cat > check_this_branch.sh <<'SCRIPT_EOF'
#!/usr/bin/env sh
# Branch-specific checks - DO NOT COMMIT TO MAIN

set -e

ERRORS=0

# Start timing
START_TIME=$(python3 -c 'import time; print(int(time.time() * 1000))' 2>/dev/null || echo "0")

printf "=== Branch Checks ===\n\n"

# Get current change info
if command -v jj >/dev/null 2>&1; then
    CURRENT_ID=$(jj log -r @ --no-graph -T 'change_id.short(7)' 2>&1)
    CURRENT_EXIT=$?
    if [ $CURRENT_EXIT -ne 0 ]; then
        printf "Current: ERROR - %s\n" "$CURRENT_ID" >&2
    else
        CURRENT_DESC=$(jj log -r @ --no-graph -T 'description.first_line()' 2>&1)
        CURRENT_EMPTY=$(jj log -r @ --no-graph -T 'if(empty, " (empty)", "")' 2>&1)
        printf "Current: %s%s - %s\n" "$CURRENT_ID" "$CURRENT_EMPTY" "$CURRENT_DESC"
    fi

    # Get parent change info
    PARENT_ID=$(jj log -r @- --no-graph -T 'change_id.short(7)' 2>&1)
    PARENT_EXIT=$?
    if [ $PARENT_EXIT -ne 0 ]; then
        printf "Parent:  ERROR - %s\n" "$PARENT_ID" >&2
    else
        PARENT_DESC=$(jj log -r @- --no-graph -T 'description.first_line()' 2>&1)
        printf "Parent:  %s - %s\n" "$PARENT_ID" "$PARENT_DESC"
    fi

    # Show distance from main
    DISTANCE=$(jj log -r '::@ ~ ::main' --no-graph -T '' 2>/dev/null | wc -l || echo "0")
    if [ "$DISTANCE" -gt 0 ] 2>/dev/null; then
        printf "Ahead:   main+%s\n" "$DISTANCE"
    fi

    # Show bookmark/branch name if set
    BOOKMARK=$(jj log -r @ --no-graph -T 'bookmarks' 2>&1 || echo "")
    if [ -n "$BOOKMARK" ] && [ "$BOOKMARK" != "(no bookmarks)" ]; then
        printf "Branch:  %s\n" "$BOOKMARK"
    fi
    printf "\n"
fi

# STATIC FILE LIST - Update when branch scope changes
# DO NOT use dynamic VCS queries like $(jj diff --name-only)
# See THIS_BRANCH.md for instructions
CHECK_FILES=""

if [ -z "$CHECK_FILES" ]; then
    printf "‚ö†Ô∏è  WARNING: CHECK_FILES is empty\n"
    printf "   Update CHECK_FILES in this script with files relevant to this branch\n"
    printf "   Example: CHECK_FILES=\"src/feature/*.js docs/*.md\"\n\n"
fi

# CRITICAL: Verify branch metadata files won't be published
printf "üîç Checking branch metadata cleanup...\n"
METADATA_IN_CHANGE=0
if command -v jj >/dev/null 2>&1; then
    # Check if any metadata files are tracked in current change
    FOUND_FILES=$(jj file list -r @ -- check_this_branch.sh THIS_BRANCH.md THIS_GIT_BRANCH.md 2>/dev/null || echo "")
    if [ -n "$FOUND_FILES" ]; then
        for file in $FOUND_FILES; do
            printf "‚ö†Ô∏è  WARNING: %s is tracked in current change\n" "$file"
        done
        METADATA_IN_CHANGE=1
    fi
fi

if [ $METADATA_IN_CHANGE -eq 1 ]; then
    printf "‚ùå ERROR: THIS CHANGE INCLUDES BRANCH METADATA FILES\n\n"
    printf "   This change is NOT READY FOR PUBLICATION until:\n"
    printf "   - THIS_BRANCH.md is removed/excluded\n"
    printf "   - check_this_branch.sh is removed/excluded\n\n"
    printf "   Use: rm THIS_BRANCH.md check_this_branch.sh\n"
    printf "   Or create these files in a separate change that won't be published\n\n"
    ERRORS=$((ERRORS + 1))
else
    printf "‚úÖ Branch metadata files excluded from change\n"
fi
printf "\n"

# CRITICAL: Check for FIXME comments (must be resolved before publishing)
if [ -n "$CHECK_FILES" ]; then
    printf "üîç Scanning for FIXME comments (blocking)...\n"
    FIXME_COUNT=0
    for file in $CHECK_FILES; do
        if [ -f "$file" ]; then
            MATCHES=$(grep -n "FIXME" "$file" 2>/dev/null || true)
            if [ -n "$MATCHES" ]; then
                printf "  %s:\n%s\n" "$file" "$MATCHES"
                FIXME_COUNT=$((FIXME_COUNT + 1))
            fi
        fi
    done

    if [ $FIXME_COUNT -gt 0 ]; then
        printf "‚ùå ERROR: Found FIXME comments in %d file(s)\n\n" "$FIXME_COUNT"
        printf "   FIXME comments MUST be resolved before publishing\n"
        printf "   Either fix them or convert to TODO if acceptable to defer\n\n"
        ERRORS=$((ERRORS + 1))
    else
        printf "‚úÖ No FIXME comments found\n"
    fi
    printf "\n"
fi

# End timing
if [ "$START_TIME" != "0" ]; then
    END_TIME=$(python3 -c 'import time; print(int(time.time() * 1000))' 2>/dev/null || echo "$START_TIME")
    ELAPSED_MS=$((END_TIME - START_TIME))
    printf "Checks finished after %d.%03d seconds\n\n" $((ELAPSED_MS / 1000)) $((ELAPSED_MS % 1000))
fi

# Summary
printf "=== Summary ===\n"
if [ $ERRORS -gt 0 ]; then
    printf "‚ùå %d error(s) found - NOT READY FOR PUBLICATION\n" "$ERRORS"
    exit 1
else
    printf "‚úÖ All checks passed\n"
    exit 0
fi
SCRIPT_EOF
    chmod +x check_this_branch.sh
    printf "   ${GREEN}‚úÖ Created check_this_branch.sh${RESET}\n"
fi

# === Final instructions ===
printf "\n${BOLD}${GREEN}‚úÖ Setup complete!${RESET}\n\n"

if [ "$FILES_EXIST" = true ]; then
    printf "${BLUE}Files already existed - no changes made${RESET}\n\n"
else
    printf "${BOLD}üìÅ Files created:${RESET}\n"
    ls -lh THIS_BRANCH.md check_this_branch.sh | awk '{print "   " $0}'
    printf "\n"
fi

printf "${BOLD}üö® IMPORTANT - Next Steps for AI Agents:${RESET}\n\n"
printf "${BOLD}1. Run check_this_branch.sh NOW to verify it works:${RESET}\n"
printf "   ./check_this_branch.sh\n\n"
printf "${BOLD}2. Update THIS_BRANCH.md:${RESET}\n"
printf "   - Fill in scope and out-of-scope sections\n"
printf "   - List your TODOs\n"
printf "   - Update CHECK_FILES pattern when you know which files you'll modify\n\n"
printf "${BOLD}3. Update check_this_branch.sh:${RESET}\n"
printf "   - Set CHECK_FILES to match files in this branch\n"
printf "   - Add project-specific checks as needed\n\n"
printf "${BOLD}4. Run check_this_branch.sh regularly:${RESET}\n"
printf "   - Before each 'jj new' or 'jj describe'\n"
printf "   - Before pushing to remote\n\n"
printf "${BLUE}See ~/.agents/rules/branch-metadata.md for detailed guidance${RESET}\n"
